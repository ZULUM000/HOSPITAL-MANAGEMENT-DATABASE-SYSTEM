# HOSPITAL-MANAGEMENT-DATABASE-SYSTEM
TSQL CODES FOR A HOSPITAL DATABASE MANAGEMENT SYSTEM
--CREATE THE HOSPITL MANAGEMENT SYSTEM DATABASE
CREATE DATABASE HMS;

--CREATE THE PATIENTS TABLE
CREATE TABLE Patients(
		PatientsID INT PRIMARY KEY IDENTITY(1,1),--THIS CREATES THE PATIENTS ID COLUMN AS THE PRIMARY KEY WITH AN ID STARTING FROM 1 WITH AN INCREASE OF 1 THIS IS THE MOST IMPORTANT VARIABLE IN THE DATABASE BECAUSE THE HOSPITAL IS BUILT AROUND THE PATIENT
		FullName VARCHAR(500) NOT NULL,-- THIS INDICATES THE FULLNAME COLUMN WITH THE DATATYPE AS A VARIABLE CHARACTER WITH A LENGTH OF AT MOST 500 CHARACTERS AND IS A COMPULSORY FIELD
		Address VARCHAR(1000) NOT NULL,-- THIS INDICATES THE ADDRESS COLUMN WITH A DATATYPE AS A VARIABLE CHARACTER WITH A MAXIMUM LENTH OF 1000 CHARACTERS AND IS A CUMPOLSORY FIELD
		DateOfBirth DATE NOT NULL,-- THIS INDICATES THE DATE OF BIRTH COLUMN WITH THE DATE DATATYPE AND IS A COMPULSORY FIELD
		Insurance VARCHAR(500) NOT NULL,-- THIS INDICATES THE INSURANCE COLUMN WITH A VARIABLE CHARACTER DATATYPE AND A NON NULL VALUE
		Username VARCHAR(50) NOT NULL UNIQUE,-- THIS CREATES THE USERNAME COLUMN WHICH IS CREATED BY THE USERS AND MUST BE UNIQUE MEANING NO TWO PEOPLE CAN HAVE THE SAME USERNAME IN THE DATABASE AND IS A COMPULSORY FIELD 
		Password VARCHAR(50) NOT NULL,-- THIS IS THE PASSWORD COLUMN IN VARIABLE CHARACTER DATATYPE AND IS A COMPULSORY FIELD
		EmailAddress VARCHAR(100) NULL,--THIS CREATES THE EMAIL COLUMN AND IS SET TO NULL MEANING IT IS AN OPTIONAL COLUMN AND IS A VARIABLE CHARACTER COLUMN
		PhoneNumber VARCHAR(20) NULL,--THIS CREATES THE PHONE NUMBER COLUMN AND IS SET TO VARCHAR DATATYPE BECAUSE IT IS A  NON CALCULATION VARIABLE AND IS NOT A COMPULSORY ENTRY
		DateLeft DATE NULL --THIS COLUMN IS THE DATE AT WHICH THE PATIENTS LEAVES THE HOSPITAL BUT THE DATA IS STILL STORED, IT IS LEFT TO NULL UNTIL THE PATIENT LEAVES
	);
SELECT * FROM Patients--CHECK IF THE TABLE HAS BEEN PROPERLY CREATED
INSERT INTO Patients (FullName, Address, DateOfBirth, Insurance, Username, Password, EmailAddress, PhoneNumber)--THIS POPULATES THE PATIENTS TABLE WITH THE NECESSARY DETAILS, LEAVING ID OUT SINCE IT IS AUTO GENERATED
VALUES;
SELECT *FROM  Patients;--CHECK IF THE TABLE HAS BEEN FILLED WITH THE APPROPRIATE DETAILS

----------


--CREATE THE DEPARTMENT TABLE, EACH SPECIALIST IS DIFFERENTIATED BY THEIR DEPARTMENTS AND EACH PATIENT IS ATTENDED TO BY A SPECIALIST SO THATS THE LINK.
CREATE TABLE Departments(
		DepartmentID INT PRIMARY KEY IDENTITY(1,1),--THIS COLUMN UNIQUELY IDENTIFIES EACH DEPARTMENT WITH A UNIQUE ID AND IS SET TO AUTO INCREAMENT OF +1 KNOWING IT IS AN INTEGER DATATYPE
		DepartmentName VARCHAR(100) NOT NULL,--THIS COLUMN REPRESENTS THE NAMES OF EACH DEPARTMENT WITH THE DATATYPE OF A VARIABLE CHARACTER
	);
	SELECT * FROM Departments;-- CONFIRM IF THE TABLE HAS BEEN CREATED 
INSERT INTO Departments(DepartmentName)--POPULATED THE DEPARTMENTS WITH A LIST OF DEPARTMENTS 
VALUES;
SELECT * FROM Departments--CONFIRM THE TABLE HAS BEEN POPULATED.

-------


/*NOW WE HAVE THE DEPARTMENT TABLE, WE NEED TO MAP EACH DEPARTMENT TO EACH SOECIALITY, JUST LIKEY A SURGEON IS IN THE DEPARTMENT OF SURGERY, SO THERE IS A NECESSITY TO JOIN EACH SPECIALIST TO EACH DEPARTMENT, ONE MAJOR 
ADVANTAGE OF THIS IS THAT WHEN WE POPULATE THE SPECIALIST TABLE, WE CAN AUTOMATICALLY GET THE DEPAARTMENT ID MAPPED TO EACH PERSON AND NOT HAVE TO IMPORT IT MANNUALLY WHICH ALSO HAVE THE TENDENCY TO CAUSE ERRORS WHEN
ENTERED MANUALLY*/
--CREATE THE TABLE THAT WOULD STORE THIS MAPPED VARIABLES
CREATE TABLE SpecialtyDepartmentMapping (
    Specialty VARCHAR(100) PRIMARY KEY,
    DepartmentID INT FOREIGN KEY REFERENCES Departments(DepartmentID)
);
SELECT * FROM SpecialtyDepartmentMapping;--VERIFY THAT THE TABLE HAS BEEN CREATED
INSERT INTO SpecialtyDepartmentMapping (Specialty, DepartmentID)--POPULATE THE TABLE WHEREBY WE SPECIFY WHICH SPECIALLIST BELONGS TO WHICH DEPARTMENT HENCE ENSURING DATA INTEGRITY.
VALUES;
SELECT * FROM SpecialtyDepartmentMapping ORDER BY DepartmentID ASC;--CONFIRM THE TABLE HAS BEEN POPULATED AND ARRANGE THE OUTPUT IN ASCENDING ORDER WITH RESPECT TO THE DEPARTMENT ID

----


--CREATE THE DOCTORS TABLE 
CREATE TABLE Doctors (
    DoctorID INT PRIMARY KEY IDENTITY(1,1),--THE DOCTORS ID COLUMN THAT IS UNIQUELY IDENTIFYING EACH DOCTOR AND LINKS EACH DOCTOR TO THEIR RESPECTIVE DEPRARTMENTS
    FullName VARCHAR(100) NOT NULL,--THE COLUMN REPRESENTING THE DOCTORS FULLNAME COLUMN TO A VAIRIABLE CHARACTER DATATYPE
    Specialty VARCHAR(100) NOT NULL,--THIS REPRESENTS THE SPECIALTY OF THE DOCTORS WITH A VARIABLE CHARACTER DATATYPE
    DepartmentID INT FOREIGN KEY REFERENCES Departments(DepartmentID)--THIS IS THE FOREIGN KEY AND IT LINKS THE DOCTOR TO THE DEPARTMENTS TABLE 
);
SELECT * FROM Doctors;
--I AM CREATING A TRIGGER THAT WOULD AUTOMATICAALY POPULATE THE DEPARTMENT ID MATCHING EACH SPEALISIT TO THEIR INDIVIDUAL DEPARTMENT, THIS IS DONE BECAUSE WE DO NOT INTEND TO POPULATE IT MANUALLY, 
--ASIDES REDUCING STRESS, IT MINIMISES ERRORS AND ENSURES DATA INTEGRITY KNWOING THAT WE CANNOT MISMATCH THE SPECIALIST TO A WRONG DEPARTMENT
CREATE TRIGGER 
AssignDoctorsDepartment
ON Doctors
AFTER INSERT
AS
	BEGIN
    UPDATE D
    SET D.DepartmentID = M.DepartmentID
    FROM Doctors D
    JOIN SpecialtyDepartmentMapping M
        ON D.Specialty = M.Specialty
    WHERE D.DepartmentID IS NULL
    AND D.DoctorID IN (SELECT DoctorID FROM inserted);
END;
-- Insert Doctors Data Without DepartmentID
INSERT INTO Doctors (FullName, Specialty)
VALUES;
SELECT * FROM Doctors ORDER BY DoctorID ASC;

---------


--CREATE THE APPOINTMENTS TABLE NEXT
CREATE TABLE Appointments (
    AppointmentID INT PRIMARY KEY IDENTITY(1,1),--THE PRIMARY KEY COLUMN THAT UNIQUELY IDENTIFIES EACH APPOINTMENT ASSIGNED TO THE PATIENTS
    PatientID INT FOREIGN KEY REFERENCES Patients(PatientsID),--THE FOREIGN KEY THAT CONNECTS THE PATIENTS TABLE TO THE APPOINTMENTS TABLE
    DoctorID INT FOREIGN KEY REFERENCES Doctors(DoctorID),--THE FOREIGN KEY THAT CONNECTS THE DOCTORS TABLE TO EACH BOOKED APPOINTMENTS
	DepartmentID INT FOREIGN KEY REFERENCES DepartmentS(DepartmentID),--REPRESENTS THE DEPARTMENT FROM WHICH THE DOCTOR APPOINTED TO IS COMING FROM
    Date DATE NOT NULL,--THE DATE FOR THE APPOINTMENT WITH THE DATE DATATYPE
    Time TIME NOT NULL,--THE TIME FOR THE APPOINTMENT AS TIME DATATYPE
    Status VARCHAR(20) CHECK (Status IN ('Pending', 'Completed', 'Cancelled')),--THIS CHECKS FOR THE STATUS OF THE APPOINTMENT FROM PENDING, COMPLETED AND CANCELLED.
    Feedback VARCHAR(5000)--REPRESENTS THE FEEDBACK FROM EACH PATIENT AFTER HE/SHE HAS BEEN ATTENDED TO
);
SELECT * FROM Appointments--



IN A WORKING SYSTEM THIS FUNCTION WOULD ENSURE THAT NO ONE DOCTOR CAN HAVE TWO TWO DIFFERENT APPOINTMENTS AT THE SAME TIME 
CREATE PROCEDURE CheckDoctorAvailability
    @DoctorID INT,
    @DesiredDate DATE,
    @DesiredTime TIME
AS
BEGIN
    IF EXISTS (
        SELECT 1
        FROM Appointments
        WHERE DoctorID = @DoctorID
        AND AppointmentDate = @DesiredDate
        AND AppointmentTime = @DesiredTime
        AND Status = 'Pending'
    )
    BEGIN
        PRINT 'Doctor is not available at the selected time';
        RETURN;
    END
    ELSE
    BEGIN
        PRINT 'Doctor is available, proceed with the appointment';
    END
END;
EXEC CheckDoctorAvailability @DoctorID = 2, @DesiredDate = '2024-09-24', @DesiredTime = '10:00:00';

-- If available, insert the appointment
INSERT INTO Appointments (PatientID, DoctorID, AppointmentDate, AppointmentTime, DepartmentID, Status)
VALUES (1, 2, '2024-09-24', '10:00:00', 1, 'Pending');


-----


INSERT INTO Appointments (PatientID, DoctorID, DepartmentID, Date, Time, Status, Feedback) 
VALUES;
SELECT * FROM Appointments;

------


--THE MDICAL RECORDS TABLE
CREATE TABLE MedicalRecords (
    RecordID INT PRIMARY KEY IDENTITY(1,1),--UNIQUELY IDENTIFIES EACH RECORD CREATED FOR EVERY PATIENTS
	PatientsID INT  FOREIGN KEY REFERENCES Patients(PatientsID),--CONNECTS THE PATIENTS TABLE TO THE RECORD TABLE AND STORES EACH PATIENT DETAIL
    DoctorID INT FOREIGN KEY REFERENCES Doctors(DoctorID),--CONNECTS THE DOCTORS TABLE TO THE MEDICAL RECORDS TABLE AND IT SHOWS WHICH DOCTOR TREATED EACH PATIENT
    AppointmentID  INT FOREIGN KEY REFERENCES Appointments(AppointmentID),--CONNCTS THE APPOINTMENT TABLE TO THE MEDICAL RECORDS TABLE
    Diagnosis VARCHAR(255) ,--SHOWS THE DIAGNOSIS FROM THE DOCTORS ASSESMENT
    Medicines VARCHAR(255),--SHOWS PRESCRIBED MEDICATIONS
    PrescribedDate DATE ,--DATE PRESCRIBED TO TAKE THE MEDICATIONS
    Allergies VARCHAR(255),--RECORDED ALLERGIES 
	DoctorsRecommendation VARCHAR(5000)--DOCTORS RECOMMENDATION
);
SELECT * FROM MedicalRecords;

INSERT INTO MedicalRecords (PatientsID, DoctorID, AppointmentID, Diagnosis, Medicines, PrescribedDate, Allergies,Doctors Recommendation)
VALUES;
SELECT * FROM MedicalRecords


------------


--TASK ENSURE THE APPOINTMENT DATE IS NOT IN THE PAST
ALTER TABLE Appointments
ADD CONSTRAINT CHK_AppointmentDate CHECK (Date >= GETDATE());

--LIST ALL PATIENTS OLDER THAN 40 WITH CANCER AS DIAGNOSIS
SELECT P.PatientsID, P.FullName, P.DateOfBirth, M.Diagnosis--SELECTS THE Patients ID, FULLNAME FROM THE PATIENTS TABLE, THE DOB FROM THE PATIENTS TABLE AND THE DIAGNOSIS  FROM THE MEDICAL RECORDS TABLE
FROM Patients P--INDICATING THE PATIENTS TABLE
JOIN MedicalRecords M ON P.PatientsID = M.PatientsID--JOINING THE MEDICAL RECORDS TABLE 
WHERE M.Diagnosis LIKE '%Cancer%' AND DATEDIFF(YEAR, P.DateOfBirth, GETDATE()) > 40;--SELECTS ONLY ROWS WITH CANCER AS DIAGNONSIS AND CHECKS IF THE PERSON IS OLDER THAN 40

--DISPLAYING THE COMPLETED APPOINTMENTS WITH THE GASTROENTEROLOGISTS 
SELECT 
    P.PatientsID,                -- Patient ID
    P.FullName AS PatientName,   -- Patient's Full Name
    A.AppointmentID,             -- Appointment ID
    A.Date,           -- Appointment Date
    A.Status,                    -- Appointment Status (Completed)
    D.FullName AS DoctorName,    -- Doctor's Full Name
    D.Specialty                  -- Doctor's Specialty
FROM 
    Appointments A
JOIN 
    Patients P ON A.PatientID = P.PatientsID  -- Joining Patients table
JOIN 
    Doctors D ON A.DoctorID = D.DoctorID     -- Joining Doctors table
WHERE 
    A.Status = 'Completed' AND D.Specialty='Gastroenterologist';                  -- Only showing completed appointments

--PAYMENTS MADE AFTER APPOINTMENTS
CREATE TABLE Billing (
    BillingID INT PRIMARY KEY IDENTITY(1,1),
    PatientID INT FOREIGN KEY REFERENCES Patients(PatientsID),
    Amount DECIMAL(10, 2) NOT NULL,
    Status VARCHAR(20) CHECK (Status IN ('Paid', 'Pending', 'Cancelled')),
    CreatedAt DATETIME DEFAULT GETDATE()
);


--TRACK THE USERS LOGIN 
CREATE TABLE UsersLogin (
    UserID INT PRIMARY KEY IDENTITY(1,1),
    Username VARCHAR(50) NOT NULL UNIQUE,
    PasswordHash VARCHAR(255) NOT NULL,
    Role VARCHAR(20) CHECK (Role IN ('admin', 'doctor', 'receptionist')),
    CreatedAt DATETIME DEFAULT GETDATE()
);

--IMPLEMENTING API FOR AUTO EMAIL SYSTEM FOR REMINDERS

--IMPLEMENTING A SEARCH FUNCTIONALITY
CREATE PROCEDURE SearchPatients
    @SearchTerm VARCHAR(100)
AS
BEGIN
    SELECT * FROM Patients
    WHERE FullName LIKE '%' + @SearchTerm + '%'
    OR EmailAddress LIKE '%' + @SearchTerm + '%';
END;


--SPECIAL ACCESS LEVELS
-- Create a role for doctors
CREATE ROLE DoctorRole;

-- Grant permission to read patients and update medical records
GRANT SELECT, UPDATE ON MedicalRecords TO DoctorRole;
GRANT SELECT ON Patients TO DoctorRole;

-- Create a role for patients
CREATE ROLE PatientRole;

-- Grant permission to read only their own medical records
GRANT SELECT ON MedicalRecords TO PatientRole;



--SETTING UP AUTOMATED BACKUPS WITH DATA ENCRYPTION
BACKUP DATABASE HMS
TO DISK = 'C:\Backups\HMS_Backup.bak'
WITH ENCRYPTION;


